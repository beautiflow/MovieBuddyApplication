# Section 2.

(1) 관심사의 분리와 계층화
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용할 수 있다.
MovieFinder 클래스는 그대로 두고 상속을 통해 새로운 형식의 메타데이터를 읽을 수 있도록 이제는 얼마든지 확장을 할 수 있다.
이처럼 부모 클래스의 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조를 디자인패턴에서는 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 굉장히 애용되는 디자인 패턴 중에 하나이다.

지금까지 우리는 관심사에 따라 영화 메타데이터를 읽는 것과 영화를 검색하는 것이라는 2개의 관심을 상 하위 클래스로 분리시켰다.
이 2개의 관심사는 변화의 성격이 다르다.
변화의 성격이 다르다는 건 변화의 이유와 시기 또는 주기 등이 다르다는 뜻입니다.
MovieFinder 는 영화 목록을 조건에 따라 필터링하는 관심사를 모아둔 곳이고 따라서 이런 관심사가 바뀌면 그때 변경이 일어난다.
즉 영화감독이나 연도가 아니라 영화의 장르나 언어로 검색을 하겠다고 하는 이런 요구사항이 또는 이런 식의 관심사가 바뀔 때 그때 MovieFinder 클래스에 변경이 일어난다는 뜻이다.
메타데이터를 읽는 관심사가 변경이 된다고 MovieFinder 클래스가 변경되지는 않는다.
반대의 경우도 마찬가지다.
상 하위 클래스로 분리하고 상속으로 구현된 하위 클래스에서 변화가 필요한 부분을 바꿔 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서
서로 영향을 주지 않은 채 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서이다.

(2) 도메인 로직 분리하기
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 하지만 널리 사용된다고 해서 가장 좋은 방법은 아니다.
상속은 2가지 관점에서 설계에 안 좋은 영향을 끼친다.
하나는 캡슐화를 위반한다는 것, 또 다른 하나는 설계를 유연하지 못하게 만든다는 것
코드를 재사용하기 위해서는 상속보다는 합성을 먼저 고려하는 것이 좋다.

인터페이스는 자바가 추상화를 위해 제공하는 가장 유용한 도구이다.
인터페이스는 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며, 참조되는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만들어 준다.
즉, 합성은 메시지를 통해 느슨하게 결합되며, 따라서 코드를 재사용하기 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
합성을 통해 다양한 메타데이터를 읽을 수 있도록 코드를 개선해보자

이제 MovieFinder 클래스는 MovieReader 객체로부터 영화목록을 취득해서 검색 기능을 수행할 수 있다.
그리고 MovieReader 인터페이스로 다양한 읽기 전략을 가진 구현체를 만들 수 있으며, 원한다면 언제든 MovieReader 구현체를 교체해서 읽기 전략을 변경할 수 있게 되었다.



# Section 3.
(1) JAXB 를 사용해서 XML 로 작성된 영화 메타데이터를 Movie 객체로 매핑하는 JaxMovieReader 를 만들었다.
(2) 메인 메소드로 만들어서 테스트하고 있는 코드를 JUnit 을 사용해서 변경하기.


# Section 4.
(1) 객체를 느슨하게 결합하기
Q. 영화 메타데이터 읽기 전략을 변경하려면 무슨 일이 일어날까?
 - 메타데이터를 읽는 행위를 변경하는 검색을 하는 행위를 하는 MovieFinder 클래스에 변경이 일어난다.
   즉, XML 형식으로 동작하게 하려면 MovieFinder 클래스에서 MovieReader 객체를 CSV 가 아니라 JaxbMovieReader 클래스를 사용하도 코드를 변경해야 한다.
   메타데이터를 읽는 방식을 자유롭게 확장하고자 추상화를 통해 분리했지만, 여전히 MovieFinder 도 함께 변경이 일어나고 있다.
   이유는 MovieFinder 클래스가 구체적인 읽기 전략, 즉 어떤 방식으로 메타데이터를 읽을 건지 구현된 클래스를 결정하고 있기 때문이다.
   단지 new 연산자를 통해 객체를 생성하는 게 다지만, 그 때문에 MovieFinder 클래스는 독립적으로 확장 가능한 클래스가 될 수 없는 상태이다.
   이 문제를 해결하기 위해서는 메타데이터를 읽는 전략을 결정하는 책임을 분리해야 한다.
   즉, MovieFinder 내부에서 결정하는 게 아니라 MovieFinder 외부에서 결정하도록 변경해야 한다는 것
   이렇게 하기 위해서 코드를 바꿔 줄 것


   이제 MovieFinder 클래스는 자신의 관심사이자 책임인 영화 검색에만 집중할 수 있게 됨
   더이상 메타데이터를 읽어 오는 방법에 대해서는 조금도 고민할 필요 없음
   생성자를 통해 전달받은 MovieReader 객체를 통해서 영화목록을 얻어 자신의 할 일을 할 뿐이다.
   메타데이터를 어떻게 변경을 하든 MovieFinder 클래스는 아무런 영향을 받지 않고 독립적으로 확장 가능한 클래스가 되었다.
   하지만 읽기 전략을 생성하고 제공하는 코드가 중복이 되어 있다. 다음 시간에 해결!

(2) 오브젝트 팩토리로 객체 생성과 사용에 대한 역할과 책임 분리하기
지금 MovieFinder 에게 메타데이터 읽기 전략을 전달하는 코드가 MovieBuddyApplication 클래스와 MovieFinderTest 클래스 양쪽에 존재한다.
중복된 코드인 동시에 객체를 생성하고 관계를 구성하는 것 또한 하나의 관심사이기 때문에 분리를 할 필요가 있다.
객체의 생성 방법을 결정하고 생성한 객체를 반환하는 역할을 수행하는 객체를 보편적으로 Factory 라고 부른다.
Factory 는 주로 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용한다.

MovieBuddyFactory 에게 객체 생성과 사용에 대한 역할과 책임을 부여하고 MovieBuddyApplication 이나 MovieFinderTest 에서는
Factory 가 생성한 MovieFinder 객체를 얻어 동작하도록 변경되었다.
이로써 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임이 분리되었다.

(3) 영화 검색 컴포넌트 테스트를 JUit 기반으로 변경하기

(4) 제어의 역전 (Inversion of Control, IoC)
 대부분의 기능이 하나의 클래스에 작성되어 동작하던 영화 친구 애플리케이션을 관심사의 분리를 통해 도메인 로직과 입출력 로직으로 분리하고, 이후 도메인 내부를 영화 메타데이터를 읽는 MovieReader와
 영화 목록을 검색하는 MovieFinder 로 또 다시 나누는 작업을 했다.

 이를 바탕으로 제어의 역전이라는 개념에 대해 알아보자.
 제어의 역전이라는 건 간단히 말해 프로그램의 제어 흐름의 구조가 뒤바뀌는 것이라고 설명할 수 있다.
 일반적으로 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고 그리고 생성된 객체에 있는 메소드를 호출한다.
 이후 호출된 객체 메소드 안에서 또 다시 사용할 객체를 결정하고, 생성하고, 호출하는 식의 흐름이 반복된다.
 제어의 역전 = 프로그램의 제어 흐름의 구조가 뒤바뀌는 것
 일반적으로 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고 그리고 생성된 객체에 있는 메소드를 호출한다.
 이후 호출된 객체 메소드 안에서 또 다시 사용할 객체를 결정하고, 생성하고, 호출하는 식의 흐름이 반복된다.
 이른 프로그램의 구조에서 각 개체는 프로그램 흐름을 결정하거나 사용할 객체를 구성하는 작업에 능동적으로 참여한다.

 모든 객체가 능동적으로 자신이 사용할 객체를 결정하고, 언제 어떻게 그 객체를 만들지를 스스로 관장한다.
 즉, 모든 종류의 흐름을 사용하는 쪽에서 제어하는 구조

 Q. Factory 를 도입한 이후의 코드는 어떻게 바뀌었는가?
 - MovieBuddyApplication 은 Factory 로부터 MovieFinder 객체를 취득해서 사용한다.
   MovieFinder 는 Factory 에 의해 만들어지고 Factory 가 공급하는 MovieReader 객체를 사용해 동작한다.

제어의 역전 원리가 적용된 코드는 객체가 자신이 사용할 객체를 스스로 결정하지 않는다. 그리고 생성도 하지 않는다.
또한 스스로도 언제 어떻게 생성되고 사용되는 지 알 수 없다.
제어 권한을 자신이 아닌 다른 대상에게 위임했기 때문이다.
자바 프로그램을 시작하는 메인 메소드를 제외한 모든 객체는 이렇게 제어 권한을 위임받은 특별한 객체에 의해 결정되고 만들어진다.

 * 제어의 역전(Inversion of Control, IoC)
 - 제어의 역전이란 프로그램 제어 흐름 구조가 뒤바뀌는 것으로 프레임워크나 서블릿 컨테이너 등에 적용된 개념이다.
 - 제어의 역전 개념을 적용하면 설계가 깨끗해지고 유연성이 증가하며 확장성이 좋아진다.
 - 특정 기술이나 환경에 종속되지 않은 보편적으로 사용되는 프로그래밍 모델이다.
 - 스프링은 제어의 역전을 모든 기능의 기초가 되는 기반기술로 삼고, 극한으로 활용한다.

JUnit 을 이용하여 MovieFinderTest 코드 변경하기


(5) 소프트웨어 설계 원칙과 디자인 패턴
지금까지 개선한 코드를 소프트웨어 설계 원칙과 패턴을 연결 지어서 살펴보기

 * SOLID 원칙 (Single responsibility. Open/closed. Liskov substitution. Interface segregation. Dependency inversion principle)
 - SOLID 는 깔끔한 설계를 위해 적용 가능한 다섯가지 소프트웨어 설계 원칙이다.
 - 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법으로 구성되어 있다.
 - 모듈과 컴포넌트 내부의 구조를 이해하기 쉽고, 변경에 유연하게 만드는데 목적을 두고 있다.

 @ 개방 폐쇄 원칙 (Open-Closed Principle: OCP) : 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
      : MovieFinder 는 메타데이터 읽기라는 기능을 확장하는 데는 열려있다. MovieFinder 에 영향을 전혀 주지 않고도 MovieReader 를 통해 얼마든지 기능을 확장할 수 있게 된다.
      : 동시에 MovieFinder 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다고 말할 수 있다.
      : 리팩토링을 하기 전의 코드를 생각해보면 확장에 필요한 유연성은 부족하고, 확장하려면 결국 내부 코드를 고쳐야 하니 변경에 구멍이 나 있는 셈이다.
      : 개방 폐쇄 원칙이 적용된 후에는 MovieReader 인터페이스를 통해 제공되는 확장 지점은 활짝 개방되어 있다.
      : 반면 인터페이스를 이용하는 MovieFinder 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

 @ 의존성 역전 원칙 (Dependency-inversion Principle: DIP) : 상위 정책은 하위 정책에 의존하면 안된다. 하위 정책이 상위 정책에 정의된 추상 타입에 의존해야 한다.
      : 리팩토링을 하기 전의 코드는 MovieFinder 가 직접 CsvMovieReader 를 의존하고 있었다.
      : 이는 상위 정책인 MovieFinder 가 하위 정책인 CsvMovieReader 에 의존하게 되는 것인데, 이런 구조에서는 추상화된 MovieReader 의 다형성이 동작하기 어렵다.
      : 즉 MovieFinder 가 직접 구체적인 CsvMovieReader 객체를 생성하기 때문에 JaxbMovieReader 와 같은 다른 MovieReader 구현체를 사용할 수가 없다.
      : 의존성 역전 원칙이 적용된 후에 코드 구조를 보면 MovieFinder 는 추상화된 MovieReader 에만 의존해서 런타임의 생성자를 통해 CsvMovie 객체를 전달받아 동작한다.
      : 때문에 다형성을 적극적으로 활용할 수 있으며 객체의 재사용성이 높아진다.

 * 관심사의 분리(Separation of Concerns)와 높은 응집도, 낮은 결합도
 - 관심이 같은 것 끼리는 한곳으로 모으고, 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리하는 것이다.
 - 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
   불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.
   높은 응집도는 클래스 레벨뿐만이 아니라 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있으며, 계층화도 이 원리에 따라 적용된다.
 - 결합도가 낮다는 건 하나의 오브젝트가 변경될 때에 관계를 맺고 있는 다른 오브젝트에 영향을 안준다는 뜻이다.
   책임과 관심사가 다른 클래스 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
   느슨한 결합은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요 없게 만들어 주는 것이 좋다.
   결합도가 낮아지면 변화에 대응하는 속도가 높아지고 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다.
   낮은 결합도는 높은 응집도보다 조금 더 민감한 원리라고도 볼 수 있음

 * 디자인 패턴(Design Pattern)
 - 소프트웨어 개발 과정에서 발견된 설계의 노하우를 정리하여 이름을 붙인 것
 - 자주 발생하는 문제에 대해 검증된 해결책을 제시함

 : MovieFinder 와 MovieReader 의 구조를 디자인 패턴의 시각에서 보면 전략 패턴에 해당한다고 볼 수 있다.
 : 전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 활용되는 패턴으로, 개방 폐쇄 원칙의 실현에도 가장 잘 들어맞는 패턴이라 볼 수 있다.
 : 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 추상화를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴
 : MovieFinder 는 전략 패턴의 콘텍스트에 해당하며 콘텍스트는 자신의 기능을 수행하는 데 필요한 기능 중에서 변경 가능한, 즉 메타데이터 읽기 알고리즘을 MovieReader 라는 인터페이스로 추상화 하고
   이를 구현한 클래스, 즉 전략을 바꿔 가면서 사용할 수 있게 분리한 것

 : 템플릿 메소드 패턴 = 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해서 전체 구조는 바꾸지 않으면서도 특정 행위를 수행하는 전략만 바꾸는 패턴

 MovieFinder 에서 영화 검색을 처리하는 주요 로직을 작성하고 영화 목록을 얻는 loadMovies 메소드만 추상화 시켰다.
 이후 상속을 통해 서브 클래스에서 영화 목록을 얻는 행위를 구체적으로 작성했다.


(6) 의존관계와 의존관계 주입 (Dependency Injection, DI)

* 의존관계와 의존관계 주입
- 의존관계는 클래스 또는 모듈이 다른 클래스 또는 모듈에 의존할 때 형성된다.
- 의존관계 주입은 의존관계에 있는 오브젝트들을 런타임 시 연결해주는 작업이다.
- 스프링 IoC 기능의 대표적인 동작원리는 의존관계 주입이다.

의존 관계 주입에는 총 3가지 방법이 있다.
# 생성자 주입(constructor injection) : 객체를 생성하는 시점에 생성자를 통한 의존관계를 주입한다.
# 설정자 주입(setter injection) : 객체를 생성 후 설정자(setter) 메서드를 통한 의존관계를 주입한다.
# 메소드 주입(method injection) : 메서드 실행 시 인자를 이용한 의존관계를 주입한다.


MovieFinder 는 MovieReader 와 연결되어 있으며, CsvMovieReader 와 JaxbMovieReader 는 MovieReader 인터페이스를 실체화하고 있다.
이처럼 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메소드를 호출하는 경우, 두 클래스 사이에 의존 관계가 있다고 말한다.
여기서 MovieFinder 클래스가 MovieReader 인터페이스와 연결되어 있다는 것
문제는 메타데이터 읽기를 하기 위해서는 CsvMovieReader 또는 JaxbMovieReader 객체가 필요하다는 것
MovieFinder 객체는 실행 시 CsvMovieReader 또는 JaxbMovieReader 객체에 의존해야 한다.
하지만 코드 수준에서는 MovieFinder 클래스는 실체화 클래스 중 그 어느 것도 의존하지 않는다.
오직 인터페이스인 MovieReader 에 의존하고 있다.
즉, 코드 시점의 의존관계와 실행 시점의 의존관계가 서로 다를 수 있다는 것 / 다시말해 클래스 사이의 의존관계와 객체 사이의 의존 관계는 동일하지 않을 수 있다.
유연하고 쉽게 재사용할 수 있으며 확장 가능한 객체 지향 설계가 가지는 특징은 코드 시점의 의존관계와 실행 시점의 의존 관계가 다르다.

코드상에서 MovieFinder 클래스는 MovieReader 인터페이스에게 메시지를 전송하지만, 실행 시점에 실행되는 메소드는 MovieFinder 와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다.
다시말해 MovieFinder 는 영화 목록을 얻겠다는 동일한 메시지를 전송하지만, 실제로 어떤 메소드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.
즉, 메시지를 수신받는 객체가 CsvMovieReader 라면 CSV 형식의 문서를 읽고 영화 목록을 반환하고, JaxbMovieReader 라면 XML 형식의 문서를 읽고 영화 목록을 반환할 것이다.
이를 다형성이라고 부름

다형성 = 객체 지향 프로그램의 코드 시점 의존관계와 실행 시점 의존 관계가 다를 수 있다는 사실을 기반으로 함
코드를 작성할 때 MovieFinder 클래스는 인터페이스인 MovieReader 에 의존한다.
따라서 코드 시점에 의존 관계는 MovieFinder 에서 MovieReader 로 향한다.
반면, 실행 시점에서 MovieFinder 객체와 실제로 상호작용하는 객체는 CsvMovieReader 또는 JaxbMovieReader 이다.
실행시점에 의존 관계는 MovieFinder 에서 CsvMovieReader 나 JaxbMovieReader 로 향한다.
이처럼 다형성은 코드 시점의 의존 관계와 실행 시점의 의존 관계를 다르게 만들 수 있는 객체 지향의 특성을 이용해 서로 다른 메소드를 실행할 수 있게 한다.
그래서 동일한 메시지를 수신했을 때 객체의 실제 클래스에 따라 다르게 동작할 수 있다.

Q. 의존하고 있다는 것은 무슨 의미?
어떤 객체가 동작하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존 관계가 형성된다.
이렇게 의존관계가 형성되면 MovieReader 의 기능이 추가되거나 또는 변경이 되었을 때 그 영향이 MovieFinder 에게 전달된다.
의존관계는 객체와 객체가 협력하기 위해서는 반드시 필요하다.
하지만 과도한 의존 관계는 애플리케이션을 수정하기 어렵게 만든다.
객체 지향 설계의 핵심은 협력을 위해 필요한 의존관계는 유지하면서도 변경을 방해하는 의존 관계는 제거하는 데 있다.
이런 관점에서 객체 지향 설계란 의존 관계를 관리하는 것이고, 객체가 변경을 받아들일 수 있게 의존관계를 정리하는 기술이라고 할 수 있다.
생성과 사용을 분리하면서 MovieFinder 에는 오로지 MovieReader 를 사용해 영화를 검색하는 책임만 남게 되었다.
이것은 외부의 다른 객체가 MovieFinder 에게 MovieReader 를 생성해 전달해야 한다는 것을 의미한다.
이처럼 외부의 독립적인 존재가 객체를 생성한 후 이를 전달해서 의존 관계를 해결하는 방법을 의존 관계 주입이라고 부른다.
이 기법을 의존 관계 주입이라고 부르는 이유는 외부에서 의존 관계 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.

제어의 역전과 의존 관계 주입은 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 함
스프링 스스로도 이 2가지 기술을 바탕으로 해서 만들어졌다.
그만큼 이 2가지를 잘 이해사고 사용하는 것이 중요


# Section 5.
(1) 스프링 컨테이너
스프링은 제어의 역전 원칙에 따라 객체의 생성, 의존 관계 주입과 같은 기능을 제공하는 IoC 컨테이너로 빈 팩토리를 제공하고 있다.
일반적으로는 빈 팩토리를 사용하는 경우보다 빈 팩토리를 확장해 만들어진 애플리케이션 콘텍스트를 주로 사용한다.
애플리케이션 콘텍스트는 빈팩토리의 특징을 그대로 가지고 있으면서 동시에 스프링 AOP 통합과 국제화 지원, 또 이벤트 기반 애플리케이션이나 웹 애플리케이션을 위한 기능을 제공한다.

그리고 스프링에서는 스프링이 제어권을 가지고 직접 생성하고 의존 관계를 주입하는 객체를 '빈'이라고 부른다.
자바 빈즈 또는 엔터프라이즈 자바 빈즈에서 말하는 빈과 비슷한 객체 단위의 애플리케이션 컴포넌트를 말한다.
동시에 스프링 빈은 스프링 컨테이너가 생성, 관계 설정, 사용 등을 제어해주는 제어의 역전 원리가 적용된 객체를 가리키는 말이기도 한다.
애플리케이션 콘텍스트 또는 빈 팩토리는 Configuration metadata 라는 빈 구성정보를 읽어 빈을 생성하고 관리한다.

빈 구성 정보를 작성하는 방법은 여러가지다.

정리하면 스프링은 IoC 컨테이너인 애플리케이션 콘텍스트나 빈 팩토리로 빈 구성 정보를 읽어 애플리케이션을 구성한다.


(2) 애플리케이션 컨텍스트로 애플리케이션 구성하기
AnnotationConfigApplicationContext 를 통해서 application context 를 생성했고 해당 application context 를 통해서 빈을 취득해서 동작하도록 변경

@Configuration 과 @Bean 을 이용해 MovieBuddyFactory 를 빈 구성정보로 만들고 Spring 의 IoC 컨테이너인 애플리케이션 컨텍스트가 MovieFinder 와 MovieReader 객체를 생성하고 관리하도록 코드를 변경함
몇 줄의 코드만으로 SpringApplication 으로 변경됨.


(3) 스프링 IoC 컨테이너와 빈
- 컨테이너는 제어의 역전 원리가 적용된 스프링 핵심 컴포넌트이다.
- 컨테이너에 의해 생성 및 조립된 후 관리(초기화, 소멸 등)되는 객체를 빈(Beans)이라 부른다.
- 빈 생성시 의존관계 주입이 일어난다.
- 빈 구성 정보를 바탕으로 비즈니스 오브젝트를 이용해 애플리케이션 구성하고 생애를 관리한다.

스프링이 여타 프레임 워크와 차별화돼서 제공해 주는 기능은 의존 관계 주입이라는 용어를 사용할 때 분명하게 드러난다.
스프링 IoC 컨테이너의 가장 기초적인 역할은 빈 구성정보를 읽고, 빈을 생성하고, 이를 관리하는 것
이때 컨테이너가 필요로 하는 빈 구성정보는 바로 빈이 어떻게 만들어지고, 어떻게 동작하게 할 건가에 대한 설정 정보이다.
스프링은 빈 구성정보를 읽고 내부적으로 Bean Definition 이라는 인터페이스 추상화된 객체를 만들어 사용한다.
스프링 IoC 컨테이너는 Bean Definition 으로 만들어진 객체를 사용해 애플리케이션을 구성한다.
따라서 빈 구성 정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않는다.

쉽고 편리하게 사용하기 위해 몇 가지 빈 구성정보 작성 방식을 제공하고 있다.
 * 빈 구성정보(Configuration Metadata)
 - 스프링 컨테이너가 빈 객체 생성 및 구성, 조립시 사용하는 설정정보다.
 - 컨테이너 기능을 설정하거나 조정이 필요할 때도 사용된다.
 - 자바, 코틀린, 그루비, XML 등 다양한 방식으로 작성할 수 있다.



