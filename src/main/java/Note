# Section 2.

(1)
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용할 수 있다.
MovieFinder 클래스는 그대로 두고 상속을 통해 새로운 형식의 메타데이터를 읽을 수 있도록 이제는 얼마든지 확장을 할 수 있다.
이처럼 부모 클래스의 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조를 디자인패턴에서는 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 굉장히 애용되는 디자인 패턴 중에 하나이다.

지금까지 우리는 관심사에 따라 영화 메타데이터를 읽는 것과 영화를 검색하는 것이라는 2개의 관심을 상 하위 클래스로 분리시켰다.
이 2개의 관심사는 변화의 성격이 다르다.
변화의 성격이 다르다는 건 변화의 이유와 시기 또는 주기 등이 다르다는 뜻입니다.
MovieFinder 는 영화 목록을 조건에 따라 필터링하는 관심사를 모아둔 곳이고 따라서 이런 관심사가 바뀌면 그때 변경이 일어난다.
즉 영화감독이나 연도가 아니라 영화의 장르나 언어로 검색을 하겠다고 하는 이런 요구사항이 또는 이런 식의 관심사가 바뀔 때 그때 MovieFinder 클래스에 변경이 일어난다는 뜻이다.
메타데이터를 읽는 관심사가 변경이 된다고 MovieFinder 클래스가 변경되지는 않는다.
반대의 경우도 마찬가지다.
상 하위 클래스로 분리하고 상속으로 구현된 하위 클래스에서 변화가 필요한 부분을 바꿔 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서
서로 영향을 주지 않은 채 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서이다.

(2)
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 하지만 널리 사용된다고 해서 가장 좋은 방법은 아니다.
상속은 2가지 관점에서 설계에 안 좋은 영향을 끼친다.
하나는 캡슐화를 위반한다는 것, 또 다른 하나는 설계를 유연하지 못하게 만든다는 것
코드를 재사용하기 위해서는 상속보다는 합성을 먼저 고려하는 것이 좋다.

인터페이스는 자바가 추상화를 위해 제공하는 가장 유용한 도구이다.
인터페이스는 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며, 참조되는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만들어 준다.
즉, 합성은 메시지를 통해 느슨하게 결합되며, 따라서 코드를 재사용하기 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
합성을 통해 다양한 메타데이터를 읽을 수 있도록 코드를 개선해보자

이제 MovieFinder 클래스는 MovieReader 객체로부터 영화목록을 취득해서 검색 기능을 수행할 수 있다.
그리고 MovieReader 인터페이스로 다양한 읽기 전략을 가진 구현체를 만들 수 있으며, 원한다면 언제든 MovieReader 구현체를 교체해서 읽기 전략을 변경할 수 있게 되었다.



# Section 3.
(1) JAXB 를 사용해서 XML 로 작성된 영화 메타데이터를 Movie 객체로 매핑하는 JaxMovieReader 를 만들었다.
(2) 메인 메소드로 만들어서 테스트하고 있는 코드를 JUnit 을 사용해서 변경하기.


# Section 4.
(1)
Q. 영화 메타데이터 읽기 전략을 변경하려면 무슨 일이 일어날까?
 - 메타데이터를 읽는 행위를 변경하는 검색을 하는 행위를 하는 MovieFinder 클래스에 변경이 일어난다.
   즉, XML 형식으로 동작하게 하려면 MovieFinder 클래스에서 MovieReader 객체를 CSV 가 아니라 JaxbMovieReader 클래스를 사용하도 코드를 변경해야 한다.
   메타데이터를 읽는 방식을 자유롭게 확장하고자 추상화를 통해 분리했지만, 여전히 MovieFinder 도 함께 변경이 일어나고 있다.
   이유는 MovieFinder 클래스가 구체적인 읽기 전략, 즉 어떤 방식으로 메타데이터를 읽을 건지 구현된 클래스를 결정하고 있기 때문이다.
   단지 new 연산자를 통해 객체를 생성하는 게 다지만, 그 때문에 MovieFinder 클래스는 독립적으로 확장 가능한 클래스가 될 수 없는 상태이다.
   이 문제를 해결하기 위해서는 메타데이터를 읽는 전략을 결정하는 책임을 분리해야 한다.
   즉, MovieFinder 내부에서 결정하는 게 아니라 MovieFinder 외부에서 결정하도록 변경해야 한다는 것
   이렇게 하기 위해서 코드를 바꿔 줄 것


이제 MovieFinder 클래스는 자신의 관심사이자 책임인 영화 검색에만 집중할 수 있게 됨
더이상 메타데이터를 읽어 오는 방법에 대해서는 조금도 고민할 필요 없음
생성자를 통해 전달받은 MovieReader 객체를 통해서 영화목록을 얻어 자신의 할 일을 할 뿐이다.
메타데이터를 어떻게 변경을 하든 MovieFinder 클래스는 아무런 영향을 받지 않고 독립적으로 확장 가능한 클래스가 되었다.
하지만 읽기 전략을 생성하고 제공하는 코드가 중복이 되어 있다. 다음 시간에 해결!







