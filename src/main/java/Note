# Section 2.

(1)
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용할 수 있다.
MovieFinder 클래스는 그대로 두고 상속을 통해 새로운 형식의 메타데이터를 읽을 수 있도록 이제는 얼마든지 확장을 할 수 있다.
이처럼 부모 클래스의 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조를 디자인패턴에서는 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 굉장히 애용되는 디자인 패턴 중에 하나이다.

지금까지 우리는 관심사에 따라 영화 메타데이터를 읽는 것과 영화를 검색하는 것이라는 2개의 관심을 상 하위 클래스로 분리시켰다.
이 2개의 관심사는 변화의 성격이 다르다.
변화의 성격이 다르다는 건 변화의 이유와 시기 또는 주기 등이 다르다는 뜻입니다.
MovieFinder 는 영화 목록을 조건에 따라 필터링하는 관심사를 모아둔 곳이고 따라서 이런 관심사가 바뀌면 그때 변경이 일어난다.
즉 영화감독이나 연도가 아니라 영화의 장르나 언어로 검색을 하겠다고 하는 이런 요구사항이 또는 이런 식의 관심사가 바뀔 때 그때 MovieFinder 클래스에 변경이 일어난다는 뜻이다.
메타데이터를 읽는 관심사가 변경이 된다고 MovieFinder 클래스가 변경되지는 않는다.
반대의 경우도 마찬가지다.
상 하위 클래스로 분리하고 상속으로 구현된 하위 클래스에서 변화가 필요한 부분을 바꿔 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서
서로 영향을 주지 않은 채 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서이다.

(2)
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 하지만 널리 사용된다고 해서 가장 좋은 방법은 아니다.
상속은 2가지 관점에서 설계에 안 좋은 영향을 끼친다.
하나는 캡슐화를 위반한다는 것, 또 다른 하나는 설계를 유연하지 못하게 만든다는 것
코드를 재사용하기 위해서는 상속보다는 합성을 먼저 고려하는 것이 좋다.

인터페이스는 자바가 추상화를 위해 제공하는 가장 유용한 도구이다.
인터페이스는 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며, 참조되는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만들어 준다.
즉, 합성은 메시지를 통해 느슨하게 결합되며, 따라서 코드를 재사용하기 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
합성을 통해 다양한 메타데이터를 읽을 수 있도록 코드를 개선해보자

이제 MovieFinder 클래스는 MovieReader 객체로부터 영화목록을 취득해서 검색 기능을 수행할 수 있다.
그리고 MovieReader 인터페이스로 다양한 읽기 전략을 가진 구현체를 만들 수 있으며, 원한다면 언제든 MovieReader 구현체를 교체해서 읽기 전략을 변경할 수 있게 되었다.



# Section 3.
(1) JAXB 를 사용해서 XML 로 작성된 영화 메타데이터를 Movie 객체로 매핑하는 JaxMovieReader 를 만들었다.
(2) 메인 메소드로 만들어서 테스트하고 있는 코드를 JUnit 을 사용해서 변경하기.


# Section 4.
(1)
Q. 영화 메타데이터 읽기 전략을 변경하려면 무슨 일이 일어날까?
 - 메타데이터를 읽는 행위를 변경하는 검색을 하는 행위를 하는 MovieFinder 클래스에 변경이 일어난다.
   즉, XML 형식으로 동작하게 하려면 MovieFinder 클래스에서 MovieReader 객체를 CSV 가 아니라 JaxbMovieReader 클래스를 사용하도 코드를 변경해야 한다.
   메타데이터를 읽는 방식을 자유롭게 확장하고자 추상화를 통해 분리했지만, 여전히 MovieFinder 도 함께 변경이 일어나고 있다.
   이유는 MovieFinder 클래스가 구체적인 읽기 전략, 즉 어떤 방식으로 메타데이터를 읽을 건지 구현된 클래스를 결정하고 있기 때문이다.
   단지 new 연산자를 통해 객체를 생성하는 게 다지만, 그 때문에 MovieFinder 클래스는 독립적으로 확장 가능한 클래스가 될 수 없는 상태이다.
   이 문제를 해결하기 위해서는 메타데이터를 읽는 전략을 결정하는 책임을 분리해야 한다.
   즉, MovieFinder 내부에서 결정하는 게 아니라 MovieFinder 외부에서 결정하도록 변경해야 한다는 것
   이렇게 하기 위해서 코드를 바꿔 줄 것


   이제 MovieFinder 클래스는 자신의 관심사이자 책임인 영화 검색에만 집중할 수 있게 됨
   더이상 메타데이터를 읽어 오는 방법에 대해서는 조금도 고민할 필요 없음
   생성자를 통해 전달받은 MovieReader 객체를 통해서 영화목록을 얻어 자신의 할 일을 할 뿐이다.
   메타데이터를 어떻게 변경을 하든 MovieFinder 클래스는 아무런 영향을 받지 않고 독립적으로 확장 가능한 클래스가 되었다.
   하지만 읽기 전략을 생성하고 제공하는 코드가 중복이 되어 있다. 다음 시간에 해결!

(2)
지금 MovieFinder 에게 메타데이터 읽기 전략을 전달하는 코드가 MovieBuddyApplication 클래스와 MovieFinderTest 클래스 양쪽에 존재한다.
중복된 코드인 동시에 객체를 생성하고 관계를 구성하는 것 또한 하나의 관심사이기 때문에 분리를 할 필요가 있다.
객체의 생성 방법을 결정하고 생성한 객체를 반환하는 역할을 수행하는 객체를 보편적으로 Factory 라고 부른다.
Factory 는 주로 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용한다.

MovieBuddyFactory 에게 객체 생성과 사용에 대한 역할과 책임을 부여하고 MovieBuddyApplication 이나 MovieFinderTest 에서는
Factory 가 생성한 MovieFinder 객체를 얻어 동작하도록 변경되었다.
이로써 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임이 분리되었다.

(3) JUnit 을 통해 코드 수정

(4)
 대부분의 기능이 하나의 클래스에 작성되어 동작하던 영화 친구 애플리케이션을 관심사의 분리를 통해 도메인 로직과 입출력 로직으로 분리하고, 이후 도메인 내부를 영화 메타데이터를 읽는 MovieReader와
 영화 목록을 검색하는 MovieFinder 로 또 다시 나누는 작업을 했다.

 이를 바탕으로 제어의 역전이라는 개념에 대해 알아보자.
 제어의 역전이라는 건 간단히 말해 프로그램의 제어 흐름의 구조가 뒤바뀌는 것이라고 설명할 수 있다.
 일반적으로 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고 그리고 생성된 객체에 있는 메소드를 호출한다.
 이후 호출된 객체 메소드 안에서 또 다시 사용할 객체를 결정하고, 생성하고, 호출하는 식의 흐름이 반복된다.
 제어의 역전 = 프로그램의 제어 흐름의 구조가 뒤바뀌는 것
 일반적으로 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고 그리고 생성된 객체에 있는 메소드를 호출한다.
 이후 호출된 객체 메소드 안에서 또 다시 사용할 객체를 결정하고, 생성하고, 호출하는 식의 흐름이 반복된다.
 이른 프로그램의 구조에서 각 개체는 프로그램 흐름을 결정하거나 사용할 객체를 구성하는 작업에 능동적으로 참여한다.

 모든 객체가 능동적으로 자신이 사용할 객체를 결정하고, 언제 어떻게 그 객체를 만들지를 스스로 관장한다.
 즉, 모든 종류의 흐름을 사용하는 쪽에서 제어하는 구조

 Q. Factory 를 도입한 이후의 코드는 어떻게 바뀌었는가?
 - MovieBuddyApplication 은 Factory 로부터 MovieFinder 객체를 취득해서 사용한다.
   MovieFinder 는 Factory 에 의해 만들어지고 Factory 가 공급하는 MovieReader 객체를 사용해 동작한다.

제어의 역전 원리가 적용된 코드는 객체가 자신이 사용할 객체를 스스로 결정하지 않는다. 그리고 생성도 하지 않는다.
또한 스스로도 언제 어떻게 생성되고 사용되는 지 알 수 없다.
제어 권한을 자신이 아닌 다른 대상에게 위임했기 때문이다.
자바 프로그램을 시작하는 메인 메소드를 제외한 모든 객체는 이렇게 제어 권한을 위임받은 특별한 객체에 의해 결정되고 만들어진다.

 * 제어의 역전(Inversion of Control, IoC)
 - 제어의 역전이란 프로그램 제어 흐름 구조가 뒤바뀌는 것으로 프레임워크나 서블릿 컨테이너 등에 적용된 개념이다.
 - 제어의 역전 개념을 적용하면 설계가 깨끗해지고 유연성이 증가하며 확장성이 좋아진다.
 - 특정 기술이나 환경에 종속되지 않은 보편적으로 사용되는 프로그래밍 모델이다.
 - 스프링은 제어의 역전을 모든 기능의 기초가 되는 기반기술로 삼고, 극한으로 활용한다.

JUnit 을 이용하여 MovieFinderTest 코드 변경하기









