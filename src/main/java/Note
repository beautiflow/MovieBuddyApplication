# Section 2.

(1) 관심사의 분리와 계층화
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용할 수 있다.
MovieFinder 클래스는 그대로 두고 상속을 통해 새로운 형식의 메타데이터를 읽을 수 있도록 이제는 얼마든지 확장을 할 수 있다.
이처럼 부모 클래스의 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조를 디자인패턴에서는 템플릿 메소드 패턴이라고 한다.
템플릿 메소드 패턴은 스프링에서 굉장히 애용되는 디자인 패턴 중에 하나이다.

지금까지 우리는 관심사에 따라 영화 메타데이터를 읽는 것과 영화를 검색하는 것이라는 2개의 관심을 상 하위 클래스로 분리시켰다.
이 2개의 관심사는 변화의 성격이 다르다.
변화의 성격이 다르다는 건 변화의 이유와 시기 또는 주기 등이 다르다는 뜻입니다.
MovieFinder 는 영화 목록을 조건에 따라 필터링하는 관심사를 모아둔 곳이고 따라서 이런 관심사가 바뀌면 그때 변경이 일어난다.
즉 영화감독이나 연도가 아니라 영화의 장르나 언어로 검색을 하겠다고 하는 이런 요구사항이 또는 이런 식의 관심사가 바뀔 때 그때 MovieFinder 클래스에 변경이 일어난다는 뜻이다.
메타데이터를 읽는 관심사가 변경이 된다고 MovieFinder 클래스가 변경되지는 않는다.
반대의 경우도 마찬가지다.
상 하위 클래스로 분리하고 상속으로 구현된 하위 클래스에서 변화가 필요한 부분을 바꿔 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서
서로 영향을 주지 않은 채 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서이다.

(2) 도메인 로직 분리하기
# 상속을 통해 다양한 메타데이터를 읽을 수 있도록 추상화하기
상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 하지만 널리 사용된다고 해서 가장 좋은 방법은 아니다.
상속은 2가지 관점에서 설계에 안 좋은 영향을 끼친다.
하나는 캡슐화를 위반한다는 것, 또 다른 하나는 설계를 유연하지 못하게 만든다는 것
코드를 재사용하기 위해서는 상속보다는 합성을 먼저 고려하는 것이 좋다.

인터페이스는 자바가 추상화를 위해 제공하는 가장 유용한 도구이다.
인터페이스는 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며, 참조되는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만들어 준다.
즉, 합성은 메시지를 통해 느슨하게 결합되며, 따라서 코드를 재사용하기 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
합성을 통해 다양한 메타데이터를 읽을 수 있도록 코드를 개선해보자

이제 MovieFinder 클래스는 MovieReader 객체로부터 영화목록을 취득해서 검색 기능을 수행할 수 있다.
그리고 MovieReader 인터페이스로 다양한 읽기 전략을 가진 구현체를 만들 수 있으며, 원한다면 언제든 MovieReader 구현체를 교체해서 읽기 전략을 변경할 수 있게 되었다.



# Section 3.
(1) JAXB 를 사용해서 XML 로 작성된 영화 메타데이터를 Movie 객체로 매핑하는 JaxMovieReader 를 만들었다.
(2) 메인 메소드로 만들어서 테스트하고 있는 코드를 JUnit 을 사용해서 변경하기.


# Section 4.
(1) 객체를 느슨하게 결합하기
Q. 영화 메타데이터 읽기 전략을 변경하려면 무슨 일이 일어날까?
 - 메타데이터를 읽는 행위를 변경하는 검색을 하는 행위를 하는 MovieFinder 클래스에 변경이 일어난다.
   즉, XML 형식으로 동작하게 하려면 MovieFinder 클래스에서 MovieReader 객체를 CSV 가 아니라 JaxbMovieReader 클래스를 사용하도 코드를 변경해야 한다.
   메타데이터를 읽는 방식을 자유롭게 확장하고자 추상화를 통해 분리했지만, 여전히 MovieFinder 도 함께 변경이 일어나고 있다.
   이유는 MovieFinder 클래스가 구체적인 읽기 전략, 즉 어떤 방식으로 메타데이터를 읽을 건지 구현된 클래스를 결정하고 있기 때문이다.
   단지 new 연산자를 통해 객체를 생성하는 게 다지만, 그 때문에 MovieFinder 클래스는 독립적으로 확장 가능한 클래스가 될 수 없는 상태이다.
   이 문제를 해결하기 위해서는 메타데이터를 읽는 전략을 결정하는 책임을 분리해야 한다.
   즉, MovieFinder 내부에서 결정하는 게 아니라 MovieFinder 외부에서 결정하도록 변경해야 한다는 것
   이렇게 하기 위해서 코드를 바꿔 줄 것


   이제 MovieFinder 클래스는 자신의 관심사이자 책임인 영화 검색에만 집중할 수 있게 됨
   더이상 메타데이터를 읽어 오는 방법에 대해서는 조금도 고민할 필요 없음
   생성자를 통해 전달받은 MovieReader 객체를 통해서 영화목록을 얻어 자신의 할 일을 할 뿐이다.
   메타데이터를 어떻게 변경을 하든 MovieFinder 클래스는 아무런 영향을 받지 않고 독립적으로 확장 가능한 클래스가 되었다.
   하지만 읽기 전략을 생성하고 제공하는 코드가 중복이 되어 있다. 다음 시간에 해결!

(2) 오브젝트 팩토리로 객체 생성과 사용에 대한 역할과 책임 분리하기
지금 MovieFinder 에게 메타데이터 읽기 전략을 전달하는 코드가 MovieBuddyApplication 클래스와 MovieFinderTest 클래스 양쪽에 존재한다.
중복된 코드인 동시에 객체를 생성하고 관계를 구성하는 것 또한 하나의 관심사이기 때문에 분리를 할 필요가 있다.
객체의 생성 방법을 결정하고 생성한 객체를 반환하는 역할을 수행하는 객체를 보편적으로 Factory 라고 부른다.
Factory 는 주로 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용한다.

MovieBuddyFactory 에게 객체 생성과 사용에 대한 역할과 책임을 부여하고 MovieBuddyApplication 이나 MovieFinderTest 에서는
Factory 가 생성한 MovieFinder 객체를 얻어 동작하도록 변경되었다.
이로써 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임이 분리되었다.

(3) 영화 검색 컴포넌트 테스트를 JUit 기반으로 변경하기

(4) 제어의 역전 (Inversion of Control, IoC)
 대부분의 기능이 하나의 클래스에 작성되어 동작하던 영화 친구 애플리케이션을 관심사의 분리를 통해 도메인 로직과 입출력 로직으로 분리하고, 이후 도메인 내부를 영화 메타데이터를 읽는 MovieReader와
 영화 목록을 검색하는 MovieFinder 로 또 다시 나누는 작업을 했다.

 이를 바탕으로 제어의 역전이라는 개념에 대해 알아보자.
 제어의 역전이라는 건 간단히 말해 프로그램의 제어 흐름의 구조가 뒤바뀌는 것이라고 설명할 수 있다.
 일반적으로 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고 그리고 생성된 객체에 있는 메소드를 호출한다.
 이후 호출된 객체 메소드 안에서 또 다시 사용할 객체를 결정하고, 생성하고, 호출하는 식의 흐름이 반복된다.
 제어의 역전 = 프로그램의 제어 흐름의 구조가 뒤바뀌는 것
 일반적으로 자바 프로그램의 흐름은 메인 메소드와 같이 프로그램이 시작되는 지점에서 사용할 객체를 결정하고 결정한 객체를 생성하고 그리고 생성된 객체에 있는 메소드를 호출한다.
 이후 호출된 객체 메소드 안에서 또 다시 사용할 객체를 결정하고, 생성하고, 호출하는 식의 흐름이 반복된다.
 이른 프로그램의 구조에서 각 개체는 프로그램 흐름을 결정하거나 사용할 객체를 구성하는 작업에 능동적으로 참여한다.

 모든 객체가 능동적으로 자신이 사용할 객체를 결정하고, 언제 어떻게 그 객체를 만들지를 스스로 관장한다.
 즉, 모든 종류의 흐름을 사용하는 쪽에서 제어하는 구조

 Q. Factory 를 도입한 이후의 코드는 어떻게 바뀌었는가?
 - MovieBuddyApplication 은 Factory 로부터 MovieFinder 객체를 취득해서 사용한다.
   MovieFinder 는 Factory 에 의해 만들어지고 Factory 가 공급하는 MovieReader 객체를 사용해 동작한다.

제어의 역전 원리가 적용된 코드는 객체가 자신이 사용할 객체를 스스로 결정하지 않는다. 그리고 생성도 하지 않는다.
또한 스스로도 언제 어떻게 생성되고 사용되는 지 알 수 없다.
제어 권한을 자신이 아닌 다른 대상에게 위임했기 때문이다.
자바 프로그램을 시작하는 메인 메소드를 제외한 모든 객체는 이렇게 제어 권한을 위임받은 특별한 객체에 의해 결정되고 만들어진다.

 * 제어의 역전(Inversion of Control, IoC)
 - 제어의 역전이란 프로그램 제어 흐름 구조가 뒤바뀌는 것으로 프레임워크나 서블릿 컨테이너 등에 적용된 개념이다.
 - 제어의 역전 개념을 적용하면 설계가 깨끗해지고 유연성이 증가하며 확장성이 좋아진다.
 - 특정 기술이나 환경에 종속되지 않은 보편적으로 사용되는 프로그래밍 모델이다.
 - 스프링은 제어의 역전을 모든 기능의 기초가 되는 기반기술로 삼고, 극한으로 활용한다.

JUnit 을 이용하여 MovieFinderTest 코드 변경하기


(5) 소프트웨어 설계 원칙과 디자인 패턴
지금까지 개선한 코드를 소프트웨어 설계 원칙과 패턴을 연결 지어서 살펴보기

 * SOLID 원칙 (Single responsibility. Open/closed. Liskov substitution. Interface segregation. Dependency inversion principle)
 - SOLID 는 깔끔한 설계를 위해 적용 가능한 다섯가지 소프트웨어 설계 원칙이다.
 - 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법으로 구성되어 있다.
 - 모듈과 컴포넌트 내부의 구조를 이해하기 쉽고, 변경에 유연하게 만드는데 목적을 두고 있다.

 @ 개방 폐쇄 원칙 (Open-Closed Principle: OCP) : 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
      : MovieFinder 는 메타데이터 읽기라는 기능을 확장하는 데는 열려있다. MovieFinder 에 영향을 전혀 주지 않고도 MovieReader 를 통해 얼마든지 기능을 확장할 수 있게 된다.
      : 동시에 MovieFinder 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다고 말할 수 있다.
      : 리팩토링을 하기 전의 코드를 생각해보면 확장에 필요한 유연성은 부족하고, 확장하려면 결국 내부 코드를 고쳐야 하니 변경에 구멍이 나 있는 셈이다.
      : 개방 폐쇄 원칙이 적용된 후에는 MovieReader 인터페이스를 통해 제공되는 확장 지점은 활짝 개방되어 있다.
      : 반면 인터페이스를 이용하는 MovieFinder 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

 @ 의존성 역전 원칙 (Dependency-inversion Principle: DIP) : 상위 정책은 하위 정책에 의존하면 안된다. 하위 정책이 상위 정책에 정의된 추상 타입에 의존해야 한다.
      : 리팩토링을 하기 전의 코드는 MovieFinder 가 직접 CsvMovieReader 를 의존하고 있었다.
      : 이는 상위 정책인 MovieFinder 가 하위 정책인 CsvMovieReader 에 의존하게 되는 것인데, 이런 구조에서는 추상화된 MovieReader 의 다형성이 동작하기 어렵다.
      : 즉 MovieFinder 가 직접 구체적인 CsvMovieReader 객체를 생성하기 때문에 JaxbMovieReader 와 같은 다른 MovieReader 구현체를 사용할 수가 없다.
      : 의존성 역전 원칙이 적용된 후에 코드 구조를 보면 MovieFinder 는 추상화된 MovieReader 에만 의존해서 런타임의 생성자를 통해 CsvMovie 객체를 전달받아 동작한다.
      : 때문에 다형성을 적극적으로 활용할 수 있으며 객체의 재사용성이 높아진다.

 * 관심사의 분리(Separation of Concerns)와 높은 응집도, 낮은 결합도
 - 관심이 같은 것 끼리는 한곳으로 모으고, 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리하는 것이다.
 - 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
   불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.
   높은 응집도는 클래스 레벨뿐만이 아니라 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있으며, 계층화도 이 원리에 따라 적용된다.
 - 결합도가 낮다는 건 하나의 오브젝트가 변경될 때에 관계를 맺고 있는 다른 오브젝트에 영향을 안준다는 뜻이다.
   책임과 관심사가 다른 클래스 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
   느슨한 결합은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요 없게 만들어 주는 것이 좋다.
   결합도가 낮아지면 변화에 대응하는 속도가 높아지고 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다.
   낮은 결합도는 높은 응집도보다 조금 더 민감한 원리라고도 볼 수 있음

 * 디자인 패턴(Design Pattern)
 - 소프트웨어 개발 과정에서 발견된 설계의 노하우를 정리하여 이름을 붙인 것
 - 자주 발생하는 문제에 대해 검증된 해결책을 제시함

 : MovieFinder 와 MovieReader 의 구조를 디자인 패턴의 시각에서 보면 전략 패턴에 해당한다고 볼 수 있다.
 : 전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 활용되는 패턴으로, 개방 폐쇄 원칙의 실현에도 가장 잘 들어맞는 패턴이라 볼 수 있다.
 : 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 추상화를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴
 : MovieFinder 는 전략 패턴의 콘텍스트에 해당하며 콘텍스트는 자신의 기능을 수행하는 데 필요한 기능 중에서 변경 가능한, 즉 메타데이터 읽기 알고리즘을 MovieReader 라는 인터페이스로 추상화 하고
   이를 구현한 클래스, 즉 전략을 바꿔 가면서 사용할 수 있게 분리한 것

 : 템플릿 메소드 패턴 = 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해서 전체 구조는 바꾸지 않으면서도 특정 행위를 수행하는 전략만 바꾸는 패턴

 MovieFinder 에서 영화 검색을 처리하는 주요 로직을 작성하고 영화 목록을 얻는 loadMovies 메소드만 추상화 시켰다.
 이후 상속을 통해 서브 클래스에서 영화 목록을 얻는 행위를 구체적으로 작성했다.


(6) 의존관계와 의존관계 주입 (Dependency Injection, DI)

* 의존관계와 의존관계 주입
- 의존관계는 클래스 또는 모듈이 다른 클래스 또는 모듈에 의존할 때 형성된다.
- 의존관계 주입은 의존관계에 있는 오브젝트들을 런타임 시 연결해주는 작업이다.
- 스프링 IoC 기능의 대표적인 동작원리는 의존관계 주입이다.

의존 관계 주입에는 총 3가지 방법이 있다.
# 생성자 주입(constructor injection) : 객체를 생성하는 시점에 생성자를 통한 의존관계를 주입한다.
# 설정자 주입(setter injection) : 객체를 생성 후 설정자(setter) 메서드를 통한 의존관계를 주입한다.
# 메소드 주입(method injection) : 메서드 실행 시 인자를 이용한 의존관계를 주입한다.


MovieFinder 는 MovieReader 와 연결되어 있으며, CsvMovieReader 와 JaxbMovieReader 는 MovieReader 인터페이스를 실체화하고 있다.
이처럼 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메소드를 호출하는 경우, 두 클래스 사이에 의존 관계가 있다고 말한다.
여기서 MovieFinder 클래스가 MovieReader 인터페이스와 연결되어 있다는 것
문제는 메타데이터 읽기를 하기 위해서는 CsvMovieReader 또는 JaxbMovieReader 객체가 필요하다는 것
MovieFinder 객체는 실행 시 CsvMovieReader 또는 JaxbMovieReader 객체에 의존해야 한다.
하지만 코드 수준에서는 MovieFinder 클래스는 실체화 클래스 중 그 어느 것도 의존하지 않는다.
오직 인터페이스인 MovieReader 에 의존하고 있다.
즉, 코드 시점의 의존관계와 실행 시점의 의존관계가 서로 다를 수 있다는 것 / 다시말해 클래스 사이의 의존관계와 객체 사이의 의존 관계는 동일하지 않을 수 있다.
유연하고 쉽게 재사용할 수 있으며 확장 가능한 객체 지향 설계가 가지는 특징은 코드 시점의 의존관계와 실행 시점의 의존 관계가 다르다.

코드상에서 MovieFinder 클래스는 MovieReader 인터페이스에게 메시지를 전송하지만, 실행 시점에 실행되는 메소드는 MovieFinder 와 협력하는 객체의 실제 클래스가 무엇인지에 따라 달라진다.
다시말해 MovieFinder 는 영화 목록을 얻겠다는 동일한 메시지를 전송하지만, 실제로 어떤 메소드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.
즉, 메시지를 수신받는 객체가 CsvMovieReader 라면 CSV 형식의 문서를 읽고 영화 목록을 반환하고, JaxbMovieReader 라면 XML 형식의 문서를 읽고 영화 목록을 반환할 것이다.
이를 다형성이라고 부름

다형성 = 객체 지향 프로그램의 코드 시점 의존관계와 실행 시점 의존 관계가 다를 수 있다는 사실을 기반으로 함
코드를 작성할 때 MovieFinder 클래스는 인터페이스인 MovieReader 에 의존한다.
따라서 코드 시점에 의존 관계는 MovieFinder 에서 MovieReader 로 향한다.
반면, 실행 시점에서 MovieFinder 객체와 실제로 상호작용하는 객체는 CsvMovieReader 또는 JaxbMovieReader 이다.
실행시점에 의존 관계는 MovieFinder 에서 CsvMovieReader 나 JaxbMovieReader 로 향한다.
이처럼 다형성은 코드 시점의 의존 관계와 실행 시점의 의존 관계를 다르게 만들 수 있는 객체 지향의 특성을 이용해 서로 다른 메소드를 실행할 수 있게 한다.
그래서 동일한 메시지를 수신했을 때 객체의 실제 클래스에 따라 다르게 동작할 수 있다.

Q. 의존하고 있다는 것은 무슨 의미?
어떤 객체가 동작하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존 관계가 형성된다.
이렇게 의존관계가 형성되면 MovieReader 의 기능이 추가되거나 또는 변경이 되었을 때 그 영향이 MovieFinder 에게 전달된다.
의존관계는 객체와 객체가 협력하기 위해서는 반드시 필요하다.
하지만 과도한 의존 관계는 애플리케이션을 수정하기 어렵게 만든다.
객체 지향 설계의 핵심은 협력을 위해 필요한 의존관계는 유지하면서도 변경을 방해하는 의존 관계는 제거하는 데 있다.
이런 관점에서 객체 지향 설계란 의존 관계를 관리하는 것이고, 객체가 변경을 받아들일 수 있게 의존관계를 정리하는 기술이라고 할 수 있다.
생성과 사용을 분리하면서 MovieFinder 에는 오로지 MovieReader 를 사용해 영화를 검색하는 책임만 남게 되었다.
이것은 외부의 다른 객체가 MovieFinder 에게 MovieReader 를 생성해 전달해야 한다는 것을 의미한다.
이처럼 외부의 독립적인 존재가 객체를 생성한 후 이를 전달해서 의존 관계를 해결하는 방법을 의존 관계 주입이라고 부른다.
이 기법을 의존 관계 주입이라고 부르는 이유는 외부에서 의존 관계 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.

제어의 역전과 의존 관계 주입은 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 함
스프링 스스로도 이 2가지 기술을 바탕으로 해서 만들어졌다.
그만큼 이 2가지를 잘 이해사고 사용하는 것이 중요


# Section 5.
(1) 스프링 컨테이너
스프링은 제어의 역전 원칙에 따라 객체의 생성, 의존 관계 주입과 같은 기능을 제공하는 IoC 컨테이너로 빈 팩토리를 제공하고 있다.
일반적으로는 빈 팩토리를 사용하는 경우보다 빈 팩토리를 확장해 만들어진 애플리케이션 콘텍스트를 주로 사용한다.
애플리케이션 콘텍스트는 빈팩토리의 특징을 그대로 가지고 있으면서 동시에 스프링 AOP 통합과 국제화 지원, 또 이벤트 기반 애플리케이션이나 웹 애플리케이션을 위한 기능을 제공한다.

그리고 스프링에서는 스프링이 제어권을 가지고 직접 생성하고 의존 관계를 주입하는 객체를 '빈'이라고 부른다.
자바 빈즈 또는 엔터프라이즈 자바 빈즈에서 말하는 빈과 비슷한 객체 단위의 애플리케이션 컴포넌트를 말한다.
동시에 스프링 빈은 스프링 컨테이너가 생성, 관계 설정, 사용 등을 제어해주는 제어의 역전 원리가 적용된 객체를 가리키는 말이기도 한다.
애플리케이션 콘텍스트 또는 빈 팩토리는 Configuration metadata 라는 빈 구성정보를 읽어 빈을 생성하고 관리한다.

빈 구성 정보를 작성하는 방법은 여러가지다.

정리하면 스프링은 IoC 컨테이너인 애플리케이션 콘텍스트나 빈 팩토리로 빈 구성 정보를 읽어 애플리케이션을 구성한다.


(2) 애플리케이션 컨텍스트로 애플리케이션 구성하기
AnnotationConfigApplicationContext 를 통해서 application context 를 생성했고 해당 application context 를 통해서 빈을 취득해서 동작하도록 변경

@Configuration 과 @Bean 을 이용해 MovieBuddyFactory 를 빈 구성정보로 만들고 Spring 의 IoC 컨테이너인 애플리케이션 컨텍스트가 MovieFinder 와 MovieReader 객체를 생성하고 관리하도록 코드를 변경함
몇 줄의 코드만으로 SpringApplication 으로 변경됨.


(3) 스프링 IoC 컨테이너와 빈
- 컨테이너는 제어의 역전 원리가 적용된 스프링 핵심 컴포넌트이다.
- 컨테이너에 의해 생성 및 조립된 후 관리(초기화, 소멸 등)되는 객체를 빈(Beans)이라 부른다.
- 빈 생성시 의존관계 주입이 일어난다.
- 빈 구성 정보를 바탕으로 비즈니스 오브젝트를 이용해 애플리케이션 구성하고 생애를 관리한다.

스프링이 여타 프레임 워크와 차별화돼서 제공해 주는 기능은 의존 관계 주입이라는 용어를 사용할 때 분명하게 드러난다.
스프링 IoC 컨테이너의 가장 기초적인 역할은 빈 구성정보를 읽고, 빈을 생성하고, 이를 관리하는 것
이때 컨테이너가 필요로 하는 빈 구성정보는 바로 빈이 어떻게 만들어지고, 어떻게 동작하게 할 건가에 대한 설정 정보이다.
스프링은 빈 구성정보를 읽고 내부적으로 Bean Definition 이라는 인터페이스 추상화된 객체를 만들어 사용한다.
스프링 IoC 컨테이너는 Bean Definition 으로 만들어진 객체를 사용해 애플리케이션을 구성한다.
따라서 빈 구성 정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않는다.

쉽고 편리하게 사용하기 위해 몇 가지 빈 구성정보 작성 방식을 제공하고 있다.
 * 빈 구성정보(Configuration Metadata)
 - 스프링 컨테이너가 빈 객체 생성 및 구성, 조립시 사용하는 설정정보다.
 - 컨테이너 기능을 설정하거나 조정이 필요할 때도 사용된다.
 - 자바, 코틀린, 그루비, XML 등 다양한 방식으로 작성할 수 있다.



# Section 6.
(1) 자바 기반의 컨테이너 구성

(2) 자바 코드로 의존관계 주입하기
첫번째 방식은 메소드 콜 방식 : 메소드를 호출해서 의존 관계를 주입하는 것
두번째 방식은 메소드 파라미터 방식 : movieFinder 빈을 생성할 수 있는 메소드에 파라미터로 필요한 의존 관계를 받아 오는 것

스프링 컨테이너는 이렇게 클래스로 자바 코드로 작성되어 있는 빈 구성 정보를 읽어들여서 어떻게 빈을 생성할지 스스로 판단할 수 있다.
movieFinder 라고 하는 메소드를 통해서 movieFinder 빈을 등록 하려고 할 때, 스프링은 이 메소드의 파라미터를 보고 "이 movieFinder 빈을 등록하려면 movieReader 라고 하는 빈이 필요하구나." 해서
스스로 내부에 movieReader 라고 하는 빈이 등록되어 있는지를 확인한다.
그로 인해 바로 위에 선언되어 있는 스프링의 빈이 찾아지게 된다.
이 찾은 빈을 통해서 메소드를 호출할 때 movieReader 객체를 넘겨주는 방식으로 동작한다.

* 스프링의 빈 스코프
스프링 컨테이너는 빈을 생성할 때 단 하나의 빈을 만들지, 아니면 빈이 요청될 때마다 새로운 빈 객체를 생성할지 결정하는 메커니즘을 가지고 있다.
이 매커니즘을 빈 스코프라고 부른다.
- 싱글톤 스코프 : 단 하나의 빈 객체만 만들 때
- 프로토타입 스코프 : 빈이 요청될 때마다 새로운 빈을 생성할 때
빈을 설정할 때 별도로 설정을 해주지 않으면 기본적으로 싱글톤 스코프가 지정된다.
웹 어플리케이션에서는 리퀘스트, 세션, 웹소켓, 애플리케이션과 같은 몇 가지 빈 스코프가 더 제공되기도 한다.

싱글톤 스코프는 모든 빈의 기본 스코프로, 스프링 컨테이너가 시작될 때 생성되고 스프링 컨테이너가 종료될 때 소멸된다.
싱글톤 스코프 빈은 스프링 컨테이너 내에서 단 하나만 생성이 되고, 그 빈을 의존하는 모든 빈에 유일한 객체를 공유한다.

프로토타입 스코프는 스프링 컨테이너가 빈을 요청받을 때마다 항상 새로운 빈을 생성해서 반환하도록 그렇게 동작한다.



@Bean  //그리고 빈 구성정보 내부에 어떤 빈이 있는가를 알려주기 위해서 @Bean 어노테이션을 사용함
    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 이 프로토타입 스코프라고 되어 있는 상수는 프로토타입이라는 문자열로 작성되어 있다고 보면 된다.
    public MovieFinder movieFinder(MovieReader movieReader){
        return new MovieFinder(movieReader);

(3) 자바 기반 빈 구성정보 조합하기
자바 코드로 작성하는 빈 구성정보는 관심사가 같은 컴포넌트들을 함께 묶어 모듈화가 가능하다.
따라서 여러 개의 빈 구성 정보를 작성하고 조합을 할 수 있다.


# Section 7.
(1) 자동 클래스 탐지로 빈 등록하기
@ComponentScan 으로 자동 클래스 탐지 기능을 활성화 하면 지정된 패키지 경로에서 @Component 과 같이 스트레오타입으로 선언되 클래스를 찾아 빈으로 등록하고 관리한다.
패키지를 지정하지 않으면 @Component 이 선언된 클래스를 기준으로 탐색한다고 보면 된다.

(2) 객체 타입으로 자동 의존관계 주입하기
springframework.stereotype  이라는 패키지 밑에는 @Component 외에도 @Controller, @Repository, @Service 와 같은 애노테이션들이 있다.
이 애노테이션들은 빈을 정의하는 데 사용되는 애노테이션으로 빈의 역할과 관련이 있다.
- @Service : 다른 빈이 필요로 하는 서비스를 제공하는 보다 복잡한 비즈니스 기능을 가진 빈을 정의하는 데 사용이 된다.
- @Repository :  데이터베이스와 같이 데이터 접근 기술이 사용되는 빈을 정의하는 데 사용된다.

(3) 빈 이름으로 자동 의존관계 주입하기


# Section 8.
(1) 스프링 통합 테스트 지원
 * 스프링 테스트 컨텍스트 프레임 워크
- 테스트에 사용되는 스프링 컨테이너를 생성 및 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크이다.
- JUnit 또는 TestNG 와 같은 자바용 테스트 프레임워크와 잘 통합되어 동작한다.
- 실 운영환경과 유사한 구성으로 동작하는 통합 테스트를 손쉽게 만들 수 있다.

(2)
@ExtendWith : JUnit 이 테스트 실행 전략을 확장할 때 사용하는 애노테이션
그리고 ExtendWith 에 제공한 SpringExtension 클래스는 스프링의 테스트 컨텍스트 프레임워크에서 제공하는 JUnit 지원 클래스로, JUnit 이 테스트를 실행하는 과정에서 테스트가 필요로하는 스프링 컨테이너를 구성하고 관리해준다.
이때 스프링 컨테이너를 구성할 때 이 @ContextConfiguration 이 지정되어 있다면 해당 애노테이션이 지정한 빈 구성 정보를 바탕으로 스프링 컨테이너를 만든다.

애노테이션을 다른 애노테이션으로 만들 때 쓰는 방법을 메타 애노테이션이라고 부름
스프링은 내부적으로 굉장히 다양한 형태의 커스텀 애노테이션을 제공하고 있고, 이런 여러개의 애노테이션을 함축된 의미의 하나의 애노테이션으로 줄여 주는 방식으로 또 많은 애노테이션들을 제공해주고 있다.



# Section 9.
(1) 데이터 원본 계층
 * 엔터프라이즈 애플리케이션의 계층
 - 프리젠테이션(Presentation) : 사용자와 소프트웨어간 상호작용을 처리한다.
 - 도메인(Domain) : 핵심 업무 논리를 처리하는 객체들로 구성되며 엔터프라이즈 애플리케이션에서 가장 중요한 자산이다.
 - 데이터원본(DataSource) : 파일 또는 데이터베이스 시스템 등과 데이터 송/수신을 처리한다. = 퍼시스턴스(persistence) 계층

소프트웨어를 계층으로 나누고 분리시키는 건 서로 변경의 주기가 다르고, 또 다른 맥락에서는 구체적인 세부 기술로부터 도메인 논리를 보호하기 위함도 있다.
도메인 계층은 핵심 업무 논리 외에는 없는 것이 가장 좋다.

현재 영화친구 애플리케이션의 구조를 보면 도메인 계층에 정의된 domain 패키지 내에는 CSV 나 XML 과 같이 세부 기술을 이용해서 영화 메타데이터 파일을 다루고 있다.
도메인 계층을 구체적인 세부 기술로부터 보호하기 위해 영화 메타데이터 파일을 다루는 객체를 데이터 원본 계층으로 분리할 필요가 있다.

(2) 데이터 원본 패키지로 데이터 접근 글래스들 옮기기
도메인 계층에 구체적인 세부 기술을 사용해 작성한 CscMovieReader 와 JaxbMovieReader 를 데이터 원본 계층으로 분리해보자

* 인터페이스가 서버 모듈 쪽에 위치하는 전통적인 모듈 구조
고려해야 할 사항 = MovieReader 인터페이스의 소유권을 어느 계층에서 가질 것인가
현재 MovieFinder 와 CsvMovieReader, JaxbMovieReader 는 모두 추상화된 MovieReader 인터페이스에 의존하고 있다.
따라서 개방 폐쇄 원칙을 준수할 뿐만이 아니 의존성 역전 원칙도 따르고 있기 때문에 이 설계가 유연하고 재사용 가능하다고 볼 수 있다.
하지만 domain 패키지만 배포 후 재사용하겠다고 한다면 불가능하다.
domain 패키지의 MovieFinder 가 data 패키지의 MovieReader 에 의존하고 있기 때문
즉 도메인 패키지가 올바르게 컴파일 되기 위해서는 data 패키지가 필요하기 때문에 두 패키지는 항상 함께 배포가 되어야 한다.
또한 data 패키지의 변경에 domain 패키지도 영향을 받는다고 볼 수 있다.
만약 MovieReader 에 의존하고 있는 다른 패키지가 생긴다면 해당 패키지 또한 영향을 받게 되며, 이런 현상을 의존성 그래프를 따라 애플리케이션 전체로 번질 수도 있다.
이 문제는 MovieReader 인터페이스를 도메인 패키지에 위치시켜서 해결할 수 있다.

* 소프트웨어의 두 가지 가치
- 행위적 가치 : 사용자가 가진 문제를 해결해주는 것
- 구조적 가치 : 변경하기 쉬운 소프트웨어를 만드는 것

* 소프트웨어를 구성하는 두 가지 요소
- 정책 : 모든 업무 규칙과 업무 절차를 구체화 한 것
- 구현 세부사항 : 입출력장치, 데이터베이스 등 시스템을 사용 또는 구동하는 데 필요한 것

(3) 스프링이 본질과 개발자의 역할
스프링은 어떻게 객체가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는 지 관심을 두는 프레임워크


# Section 10.
(1) 애플리케이션이 XML 읽기 컴포넌트를 사용하도록 변경하기
Q. XML 문서를 읽고 동작하게 하려면 무엇이 변경되나요?
- XML 문서를 읽고 동작하게 하려면 바로 MovieFinder 가 JaxbMovieReader 를 의존 관계 주입 받아 동작하도록 코드를 변경해야 한다.

(2) 빈 정의 프로파일로 애플리케이션 구성 전략 다루기
스프링 공식문서 코어에 있는 레퍼런스 문서를 본다.
1.13.Environment Abstraction 부분에 Bean Definition Profiles 라는 기능이 있다.
빈 정의 프로파일은 환경에 따라 다른 빈을 등록할 수 있게 하는 메커니즘이다.
여기서 환경이라는 용어는 각자가 처한 상황에 따라 다르게 해석이 될 수 있는데 스프링 레퍼런스에서는 다음 사례와 같다고 설명한다.
개발 서버와 QA 서버 또는 프로덕션 서버에서 사용하는 데이터 소스의 유형이 다를 때, 성능 검증 서버에서 배포 시에만 모니터링 인프라를 활성화시킬 때, 고객별로 사용자화된 애플리케이션을 제공할 때.
영화친구 애플리케이션은 사용자에 따라 Csv 문서 또는 XML 문서를 읽고 동작해야 하는 상황이니, 마지막 사례인 고객별로 사용자화된 애플리케이션을 제공해야 할 때와 유사한 상황으로 보인다.

이 빈 정의 프로파일을 이용해서 영화 메타데이터 읽기 전략을 제어를 한번 해본다.

영화버디애플리케이션을 실행할 때 적절한 프로파일을 주지 않았기 때문에 MovieReader 를 찾을 수 없어 실행이 실패한다.
테스트에서는 @ActiveProfiles 라는 애노테이션을 사용해서 프로파일을 활성화할 수 있었지만, 프로덕션 환경에서는 다른 방법을 사용해야한다.
프로파일을 활성화 하는 방법
- 첫번째 방식은 애플리케이션 컨텍스트가 제공하는 Environment 객체를 통해서 setActiveProfiles 라는 메소드로 해당 컨텍스트의 프로파일을 활성화시키는 방법이다.
  이 방식을 쓸 때는 실제로 프로파일을 활성화시킨 다음에 애플리케이션 컨첵스트를 구성해 줘야 되는 방식으로 작업을 해야 한다.
- 두번째 방식은 선언적으로 외부 환경 변수를 통해서 활성화시켜 줄 수 있다.
  자바 애플리케이션을 실행할 때 JVM 옵션을 통해서 실행할 수 있다. 또는 이외에도 시스템 환경 변수나 서블릿 컨텍스트 파라미터 등을 통해서 이 옵션을 활성화시킬 수 있다.

(3)
스프링 5.0 부터는 스프링 JCL 모듈을 통해 자바 프로젝트에서 많이 사용되는 로깅 프레임워크인 SLF4J 와 Log4J 2.0 API 를 지원하고 있다.
스프링이 출력하는 로그를 보려면 지원되는 로깅 프레임워크를 애플리케이션 의존성에 추가하고 로거 설정 정보를 작성하면 된다.

SLF4J 를 사용해서 로그를 출력하기
SLF4J 는 자바 진영에서 사용되는 여러 로깅 프레임워크를 추상화해서 만들어진 인터페이스 모음이다.
파사드 패턴을 이용한 로깅 프레임워크
Simple Logging Facade for Java 의 첫 글자를 따서 SLF4J 라고 부른다.
SLF4J 는 추상 로깅 프레임워크이기 때문에 단독으로는 로깅을 할 수가 없다.
보통은 네이티브 구현체인 Logback 이나 Log4J 와 같은 구현체를 이용해서 사용한다.
애플리케이션에 SLF4J API 와 Logback 의존성을 추가하고 로그를 한번 출력해보자


# Section 11.
(2) 스프링 OXM 서비스 추상화로 XML 읽기 로직 개선하기
XmlMovieReader 는 특정 환경과 구현 기술에 종속되지 않게 작성된 포조가 되었다.
Spring OXM 서비스 추상화로 코드 수정 없이도 OXM 기술을 얼마든지 변경할 수 있게 되었다.

(3) 이식 가능한 서비스 추상화
 * 이식 가능한 서비스 추상화
 - 환경과 구현 기술의 변경과 무관하게 일관된 방식으로 기술을 다룰 수 있게 지원한다.
 - 엔터프라이즈 애플리케이션에 사용되는 다양한 기술의 서비스 추상화가 제공된다.
 - 제어의 역전 원리를 통해 POJO 에게 제공된다.
     + POJO 로 개발된 코드는 특정 환경이나 구현 방식에 종속되지 않아야 한다.


     ## 요구사항 완료 -> 1. XML 문서로 작성된 영화 메타데이터도 다룰 수 있게 기능을 확장하라






